# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M8hgu2P8uL6WWXYaIw5Kr6lPwBwoQQRy

"""
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import deepchem as dc 

#from rdkit import Chem


#############################################################################
"""## Featurizer """

def featurize(column):
    '''
    parameter:
    ------------
    column: training molecules of smiles format
    
    Return:
    ------------
    train_nodes: featurized nodes
    train_edges: featurized edges
    '''
    featurizer = dc.feat.MolGraphConvFeaturizer(use_edges=True)
    feats = featurizer.featurize(column)
    
    train_nodes = [ i.node_features.sum(axis = 0) for i in feats ]
    train_edges = [ e.edge_features.sum(axis = 0) for e in feats ]
    #sum the one-hot features along column so that each representation is of the same length
    
    return train_nodes, train_edges



##########################################################################

"""## Data Preparation"""

def prepare_data(input_df, minimum_length ):
    '''
    this function:
    1. prepares the data(set minimum length)(exclusive)
    2. featurize
    Refer to here for more details about the featurizer:
    https://deepchem.readthedocs.io/en/latest/api_reference/featurizers.html#deepchem.feat.MolGraphConvFeaturizer
    
    '''
    try:
        from rdkit import Chem
    except ModuleNotFoundError:
        raise ImportError("This function requires RDKit to be installed. To install, refer to here: https://www.rdkit.org/docs/Install.html")
    
    #get the length and exclude those shorter than minimum length
    input_df['length'] = input_df['smiles'].apply(lambda x :Chem.MolFromSmiles(x).GetNumAtoms())
    df = input_df[input_df['length'] > minimum_length]
    
    y = df['activity']
   
    #featurize
    
    #out = featurizer.featurize(smiles)
    
    
    return df, y

##########################################################################
"""---------------------

## Discriminator model
"""

def make_model():
    '''
     Creates a simple dense layer and dropout model. 
     Model inputs:
     ------
     nodes: one-hot encoded array describing characteristics of the molecule
     edges: one-hot encoded array containing bond information between each atom of the molecule
     
     Return:
     ------
     two possible rdkit molecules(since the generated molecule graph's edges contains diagonally two possibilities of bond            informations
    '''
      # conv part for learning edges matrix features
    conv_edge = tf.keras.layers.Dense(32, activation = 'relu')
    edges_tensor = tf.keras.layers.Input(shape = (11,), name = 'edges')
    x_edge = conv_edge(edges_tensor)
  
    x_edge = tf.keras.layers.Dense(32, activation='relu')(x_edge)
    #x_edge = tf.keras.layers.Flatten()(x_edge) 
    x_edge = tf.keras.layers.Dropout(0.2)(x_edge)
    x_edge = tf.keras.layers.Dense(64, activation = 'relu')(x_edge)

    # dense layer part for nodes array features
    nodes_tensor = tf.keras.layers.Input(shape = (30,), name = 'nodes' )
    x_node = tf.keras.layers.Dense(32, activation = 'relu' )(nodes_tensor)
    x_node = tf.keras.layers.Dropout(0.2)(x_node)
    x_node = tf.keras.layers.Dense(64, activation = 'relu')(nodes_tensor)

    main = tf.keras.layers.concatenate([x_node,x_edge], axis = 1)
    main = tf.keras.layers.Dense(32, activation='relu')(main)
    output = tf.keras.layers.Dense(1, activation = 'sigmoid', name = 'label')(main)#binary classfication task with sigmoid as the activation
    
    model = keras.Model(
       inputs = [nodes_tensor, edges_tensor],
       outputs = output
       )
    model.compile(loss='binary_crossentropy', optimizer='adam')
  
    return model


##########################################################################

"""---------------------

## Payoff function
"""

def test(df, model, output=False):
    '''
    parameters:
    ---------
    
    df: molecules to be tested(in smiles format)
    model: a trained model for prediction
    output: whether the result csv would be saved to the directory, default false
    '''
    n, e = featurize(df)
    
    results = {'smiles': df,
      
              'prediction': np.concatenate(model.predict([np.array(n), np.array(e)]))
            } 
    df = pd.DataFrame(results)
    df = df.sort_values(by='prediction',ascending = False)
    
    if output == True:
        df.to_csv('cool.csv')
        
    return df











