# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M8hgu2P8uL6WWXYaIw5Kr6lPwBwoQQRy

"""
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import numpy as np
#from rdkit import Chem



##########################################################################

"""## Data Preparation"""

def prepare_data(input_df, minimum_length ):
    '''
    this function:
    1. prepares the data(set minimum length)(exclusive)
    2. featurize
    Refer to here for more details about the featurizer:
    https://deepchem.readthedocs.io/en/latest/api_reference/featurizers.html#deepchem.feat.MolGraphConvFeaturizer
    
    '''
    try:
        from rdkit import Chem
    except ModuleNotFoundError:
        raise ImportError("This function requires RDKit to be installed. To install, refer to here: https://www.rdkit.org/docs/Install.html")
    
    #get the length and exclude those shorter than minimum length
    input_df['length'] = input_df['smiles'].apply(lambda x :Chem.MolFromSmiles(x).GetNumAtoms())
    df = input_df[input_df['length'] > minimum_length]
    y = df['activity']
   
    #featurize
    featurizer = dc.feat.MolGraphConvFeaturizer(use_edges=True)
    feats = featurizer.featurize(df['smiles'])
    
    train_nodes = [ i.node_features.sum(axis = 0) for i in feats ]
    train_edges = [ e.edge_features.sum(axis = 0) for e in feats ]
    
    return train_nodes, train_edges, y
    

##########################################################################
"""---------------------

## Discriminator model
"""

def make_model():
    '''
     Creates a simple dense layer and dropout model. 
     Model inputs:
     ------
     nodes: one-hot encoded array describing characteristics of the molecule
     edges: one-hot encoded array containing bond information between each atom of the molecule
     
     Return:
     ------
     two possible rdkit molecules(since the generated molecule graph's edges contains diagonally two possibilities of bond            informations
    '''
      # conv part for learning edges matrix features
    conv_edge = tf.keras.layers.Dense(32, activation = 'relu')
    edges_tensor = tf.keras.layers.Input(shape = (11,), name = 'edges')
    x_edge = conv_edge(edges_tensor)
  
    x_edge = tf.keras.layers.Dense(32, activation='relu')(x_edge)
    #x_edge = tf.keras.layers.Flatten()(x_edge) 
    x_edge = tf.keras.layers.Dropout(0.2)(x_edge)
    x_edge = tf.keras.layers.Dense(64, activation = 'relu')(x_edge)

    # dense layer part for nodes array features
    nodes_tensor = tf.keras.layers.Input(shape = (30,), name = 'nodes' )
    x_node = tf.keras.layers.Dense(32, activation = 'relu' )(nodes_tensor)
    x_node = tf.keras.layers.Dropout(0.2)(x_node)
    x_node = tf.keras.layers.Dense(64, activation = 'relu')(nodes_tensor)

    main = tf.keras.layers.concatenate([x_node,x_edge], axis = 1)
    main = tf.keras.layers.Dense(32, activation='relu')(main)
    output = tf.keras.layers.Dense(1, activation = 'sigmoid', name = 'label')(main)#binary classfication task with sigmoid as the activation
    
    model = keras.Model(
       inputs = [nodes_tensor, edges_tensor],
       outputs = output
       )
    model.compile(loss='binary_crossentropy', optimizer='adam')
  
    return model


##########################################################################

